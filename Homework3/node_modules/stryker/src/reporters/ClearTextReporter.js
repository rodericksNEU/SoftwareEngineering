"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chalk_1 = require("chalk");
var report_1 = require("stryker-api/report");
var ClearTextScoreTable_1 = require("./ClearTextScoreTable");
var os = require("os");
var typed_inject_1 = require("typed-inject");
var plugin_1 = require("stryker-api/plugin");
var ClearTextReporter = /** @class */ (function () {
    function ClearTextReporter(log, options) {
        this.log = log;
        this.options = options;
        this.out = process.stdout;
        this.configConsoleColor();
    }
    ClearTextReporter.prototype.writeLine = function (output) {
        this.out.write("" + (output || '') + os.EOL);
    };
    ClearTextReporter.prototype.configConsoleColor = function () {
        if (!this.options.allowConsoleColors) {
            chalk_1.default.level = 0; // All colors disabled
        }
    };
    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {
        var _this = this;
        this.writeLine();
        var totalTests = 0;
        // use these fn's in order to preserve the 'this` pointer
        var logDebugFn = function (input) { return _this.log.debug(input); };
        var writeLineFn = function (input) { return _this.writeLine(input); };
        mutantResults.forEach(function (result, index) {
            if (result.testsRan) {
                totalTests += result.testsRan.length;
            }
            switch (result.status) {
                case report_1.MutantStatus.Killed:
                    _this.log.debug(chalk_1.default.bold.green('Mutant killed!'));
                    _this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.TimedOut:
                    _this.log.debug(chalk_1.default.bold.yellow('Mutant timed out!'));
                    _this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.RuntimeError:
                    _this.log.debug(chalk_1.default.bold.yellow('Mutant caused a runtime error!'));
                    _this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.TranspileError:
                    _this.log.debug(chalk_1.default.bold.yellow('Mutant caused a transpile error!'));
                    _this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.Survived:
                    _this.logMutantResult(result, index, writeLineFn);
                    break;
                case report_1.MutantStatus.NoCoverage:
                    _this.logMutantResult(result, index, writeLineFn);
                    break;
            }
        });
        this.writeLine("Ran " + (totalTests / mutantResults.length).toFixed(2) + " tests per mutant on average.");
    };
    ClearTextReporter.prototype.logMutantResult = function (result, index, logImplementation) {
        logImplementation(index + ". [" + report_1.MutantStatus[result.status] + "] " + result.mutatorName);
        logImplementation(this.colorSourceFileAndLocation(result.sourceFilePath, result.location.start));
        result.originalLines.split('\n').forEach(function (line) {
            logImplementation(chalk_1.default.red('-   ' + line));
        });
        result.mutatedLines.split('\n').forEach(function (line) {
            logImplementation(chalk_1.default.green('+   ' + line));
        });
        logImplementation('');
        if (this.options.coverageAnalysis === 'perTest') {
            this.logExecutedTests(result, logImplementation);
        }
        else if (result.testsRan && result.testsRan.length > 0) {
            logImplementation('Ran all tests for this mutant.');
        }
    };
    ClearTextReporter.prototype.colorSourceFileAndLocation = function (sourceFilePath, position) {
        var clearTextReporterConfig = this.options.clearTextReporter;
        if (clearTextReporterConfig && clearTextReporterConfig.allowColor !== false) {
            return sourceFilePath + ':' + position.line + ':' + position.column;
        }
        return [
            chalk_1.default.cyan(sourceFilePath),
            chalk_1.default.yellow("" + position.line),
            chalk_1.default.yellow("" + position.column),
        ].join(':');
    };
    ClearTextReporter.prototype.logExecutedTests = function (result, logImplementation) {
        var clearTextReporterConfig = this.options.clearTextReporter || {};
        if (!clearTextReporterConfig.logTests) {
            return;
        }
        if (result.testsRan && result.testsRan.length > 0) {
            var testsToLog = 3;
            if (typeof clearTextReporterConfig.maxTestsToLog === 'number') {
                testsToLog = clearTextReporterConfig.maxTestsToLog;
            }
            if (testsToLog > 0) {
                logImplementation('Tests ran: ');
                for (var i = 0; i < testsToLog; i++) {
                    if (i > result.testsRan.length - 1) {
                        break;
                    }
                    logImplementation('    ' + result.testsRan[i]);
                }
                if (testsToLog < result.testsRan.length) {
                    logImplementation("  and " + (result.testsRan.length - testsToLog) + " more tests!");
                }
                logImplementation('');
            }
        }
    };
    ClearTextReporter.prototype.onScoreCalculated = function (score) {
        this.writeLine(new ClearTextScoreTable_1.default(score, this.options.thresholds).draw());
    };
    ClearTextReporter.inject = typed_inject_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options);
    return ClearTextReporter;
}());
exports.default = ClearTextReporter;
//# sourceMappingURL=ClearTextReporter.js.map