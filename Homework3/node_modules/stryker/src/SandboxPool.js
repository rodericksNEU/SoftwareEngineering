"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var os = require("os");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var Sandbox_1 = require("./Sandbox");
var plugin_1 = require("stryker-api/plugin");
var di_1 = require("./di");
var MAX_CONCURRENT_INITIALIZING_SANDBOXES = 2;
var SandboxPool = /** @class */ (function () {
    function SandboxPool(log, options, testFramework, initialRunResult, initialFiles, loggingContext) {
        var _this = this;
        this.log = log;
        this.options = options;
        this.testFramework = testFramework;
        this.initialFiles = initialFiles;
        this.loggingContext = loggingContext;
        this.allSandboxes = [];
        this.runInSandbox = function (_a) {
            var mutant = _a[0], sandbox = _a[1];
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var result;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, sandbox.runMutant(mutant)];
                        case 1:
                            result = _b.sent();
                            return [2 /*return*/, { result: result, sandbox: sandbox }];
                    }
                });
            });
        };
        this.registerSandbox = function (promisedSandbox) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.allSandboxes.push(promisedSandbox);
                return [2 /*return*/, promisedSandbox];
            });
        }); };
        this.overheadTimeMS = initialRunResult.overheadTimeMS;
    }
    SandboxPool.prototype.runMutants = function (mutants) {
        var recycledSandboxes = new rxjs_1.Subject();
        // Make sure sandboxes get recycled
        var sandboxes = this.startSandboxes().pipe(operators_1.merge(recycledSandboxes));
        return mutants.pipe(operators_1.zip(sandboxes), operators_1.flatMap(this.runInSandbox), operators_1.tap(function (_a) {
            var sandbox = _a.sandbox;
            recycledSandboxes.next(sandbox);
        }), operators_1.map(function (_a) {
            var result = _a.result;
            return result;
        }));
    };
    SandboxPool.prototype.startSandboxes = function () {
        var _this = this;
        var concurrency = this.determineConcurrency();
        return rxjs_1.range(0, concurrency).pipe(operators_1.flatMap(function (n) {
            return _this.registerSandbox(Sandbox_1.default.create(_this.options, n, _this.initialFiles, _this.testFramework, _this.overheadTimeMS, _this.loggingContext));
        }, MAX_CONCURRENT_INITIALIZING_SANDBOXES));
    };
    SandboxPool.prototype.determineConcurrency = function () {
        var numConcurrentRunners = os.cpus().length;
        if (this.options.transpilers.length) {
            // If transpilers are configured, one core is reserved for the compiler (for now)
            numConcurrentRunners--;
        }
        var numConcurrentRunnersSource = 'CPU count';
        if (numConcurrentRunners > this.options.maxConcurrentTestRunners && this.options.maxConcurrentTestRunners > 0) {
            numConcurrentRunners = this.options.maxConcurrentTestRunners;
            numConcurrentRunnersSource = 'maxConcurrentTestRunners config';
        }
        if (numConcurrentRunners <= 0) {
            numConcurrentRunners = 1;
        }
        this.log.info("Creating " + numConcurrentRunners + " test runners (based on " + numConcurrentRunnersSource + ")");
        return numConcurrentRunners;
    };
    SandboxPool.prototype.disposeAll = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sandboxes;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(this.allSandboxes)];
                    case 1:
                        sandboxes = _a.sent();
                        return [2 /*return*/, Promise.all(sandboxes.map(function (sandbox) { return sandbox.dispose(); }))];
                }
            });
        });
    };
    SandboxPool.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.testFramework, di_1.coreTokens.initialRunResult, di_1.coreTokens.transpiledFiles, di_1.coreTokens.loggingContext);
    return SandboxPool;
}());
exports.SandboxPool = SandboxPool;
//# sourceMappingURL=SandboxPool.js.map