import { StrykerOptions } from 'stryker-api/core';
import LoggingClientContext from '../logging/LoggingClientContext';
import { InjectionToken, InjectableClass } from 'typed-inject';
import { OptionsContext } from 'stryker-api/plugin';
declare type Func<TS extends any[], R> = (...args: TS) => R;
declare type PromisifiedFunc<TS extends any[], R> = (...args: TS) => Promise<R>;
export declare type Promisified<T> = {
    [K in keyof T]: T[K] extends PromisifiedFunc<any, any> ? T[K] : T[K] extends Func<infer TS, infer R> ? PromisifiedFunc<TS, R> : () => Promise<T[K]>;
};
export default class ChildProcessProxy<T> {
    readonly proxy: Promisified<T>;
    private readonly worker;
    private readonly initTask;
    private disposeTask;
    private currentError;
    private readonly workerTasks;
    private readonly log;
    private readonly stdoutAndStderrBuilder;
    private isDisposed;
    private constructor();
    /**
     * @description Creates a proxy where each function of the object created using the constructorFunction arg is ran inside of a child process
     */
    static create<TAdditionalContext, R, Tokens extends InjectionToken<OptionsContext & TAdditionalContext>[]>(requirePath: string, loggingContext: LoggingClientContext, options: StrykerOptions, additionalInjectableValues: TAdditionalContext, workingDirectory: string, InjectableClass: InjectableClass<TAdditionalContext & OptionsContext, R, Tokens>): ChildProcessProxy<R>;
    private send;
    private initProxy;
    private forward;
    private listenForMessages;
    private listenToStdoutAndStderr;
    private reportError;
    private handleUnexpectedExit;
    private handleError;
    private innerProcessIsCrashed;
    dispose(): Promise<void>;
    private logUnidentifiedMessage;
}
export {};
//# sourceMappingURL=ChildProcessProxy.d.ts.map