"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var core_1 = require("stryker-api/core");
var TranspiledMutant_1 = require("../TranspiledMutant");
var util_1 = require("@stryker-mutator/util");
var plugin_1 = require("stryker-api/plugin");
var di_1 = require("../di");
var rxjs_2 = require("rxjs");
var operators_1 = require("rxjs/operators");
var rxjs_3 = require("rxjs");
var INITIAL_CONCURRENCY = 100;
var MutantTranspileScheduler = /** @class */ (function () {
    /**
     * Creates a mutant transpiler
     */
    function MutantTranspileScheduler(transpiler, unMutatedFiles) {
        var _this = this;
        this.transpiler = transpiler;
        this.unMutatedFiles = unMutatedFiles;
        this.concurrencyTicket$ = new rxjs_3.BehaviorSubject(INITIAL_CONCURRENCY);
        /**
         * Schedule next mutant to be transpiled
         */
        this.scheduleNext = function () {
            _this.concurrencyTicket$.next(1);
        };
    }
    MutantTranspileScheduler.prototype.scheduleTranspileMutants = function (allMutants) {
        var _this = this;
        return rxjs_2.from(allMutants).pipe(operators_1.zip(this.concurrencyTicket$.pipe(operators_1.flatMap(function (n) { return rxjs_1.range(0, n); }))), operators_1.flatMap(function (_a) {
            var mutant = _a[0];
            return _this.transpileMutant(mutant);
        }, 1 /* IMPORTANT! Never transpile multiple mutants at once! */));
    };
    /**
     * Dispose all
     */
    MutantTranspileScheduler.prototype.dispose = function () {
        this.concurrencyTicket$.complete();
        // TODO: Let typed-inject dispose this one
        this.transpiler.dispose();
    };
    MutantTranspileScheduler.prototype.createTranspiledMutant = function (mutant, transpileResult) {
        return new TranspiledMutant_1.default(mutant, transpileResult, someFilesChanged(this.unMutatedFiles));
        function someFilesChanged(unMutatedFiles) {
            return transpileResult.outputFiles.some(function (file) { return fileChanged(file, unMutatedFiles); });
        }
        function fileChanged(file, unMutatedFiles) {
            if (unMutatedFiles) {
                var unMutatedFile = unMutatedFiles.find(function (f) { return f.name === file.name; });
                return !unMutatedFile || unMutatedFile.textContent !== file.textContent;
            }
            else {
                return true;
            }
        }
    };
    MutantTranspileScheduler.prototype.transpileMutant = function (mutant) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var filesToTranspile, mutatedFile, transpiledFiles, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        filesToTranspile = [];
                        if (this.currentMutatedFile && this.currentMutatedFile.name !== mutant.fileName) {
                            filesToTranspile.push(this.currentMutatedFile.file);
                        }
                        this.currentMutatedFile = mutant.sourceFile;
                        mutatedFile = new core_1.File(mutant.fileName, Buffer.from(mutant.mutatedCode));
                        filesToTranspile.push(mutatedFile);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.transpiler.transpile(filesToTranspile)];
                    case 2:
                        transpiledFiles = _a.sent();
                        return [2 /*return*/, this.createTranspiledMutant(mutant, { outputFiles: transpiledFiles, error: null })];
                    case 3:
                        error_1 = _a.sent();
                        return [2 /*return*/, this.createTranspiledMutant(mutant, { outputFiles: [], error: util_1.errorToString(error_1) })];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    MutantTranspileScheduler.inject = plugin_1.tokens(di_1.coreTokens.transpiler, di_1.coreTokens.transpiledFiles);
    return MutantTranspileScheduler;
}());
exports.MutantTranspileScheduler = MutantTranspileScheduler;
//# sourceMappingURL=MutantTranspileScheduler.js.map