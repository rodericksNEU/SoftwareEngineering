"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("@stryker-mutator/util");
var plugin_1 = require("stryker-api/plugin");
var di_1 = require("../di");
var ChildProcessTestRunnerWorker = /** @class */ (function () {
    function ChildProcessTestRunnerWorker(sandboxFileNames, _a, injector) {
        var testRunner = _a.testRunner;
        this.underlyingTestRunner = injector
            .provideValue(plugin_1.commonTokens.sandboxFileNames, sandboxFileNames)
            .injectFunction(di_1.PluginCreator.createFactory(plugin_1.PluginKind.TestRunner))
            .create(testRunner);
    }
    ChildProcessTestRunnerWorker.prototype.init = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.underlyingTestRunner.init) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.underlyingTestRunner.init()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    ChildProcessTestRunnerWorker.prototype.dispose = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.underlyingTestRunner.dispose) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.underlyingTestRunner.dispose()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    ChildProcessTestRunnerWorker.prototype.run = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.underlyingTestRunner.run(options)];
                    case 1:
                        result = _a.sent();
                        // If the test runner didn't report on coverage, let's try to do it ourselves.
                        if (!result.coverage) {
                            result.coverage = global.__coverage__;
                        }
                        if (result.errorMessages) {
                            // errorMessages should be a string[]
                            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here
                            // https://github.com/stryker-mutator/stryker/issues/141
                            result.errorMessages = result.errorMessages.map(util_1.errorToString);
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    ChildProcessTestRunnerWorker.inject = plugin_1.tokens(plugin_1.commonTokens.sandboxFileNames, plugin_1.commonTokens.options, plugin_1.commonTokens.injector);
    return ChildProcessTestRunnerWorker;
}());
exports.ChildProcessTestRunnerWorker = ChildProcessTestRunnerWorker;
//# sourceMappingURL=ChildProcessTestRunnerWorker.js.map