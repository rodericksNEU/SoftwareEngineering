"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("stryker-api/core");
var util_1 = require("@stryker-mutator/util");
var objectUtils_1 = require("../utils/objectUtils");
var plugin_1 = require("stryker-api/plugin");
var di_1 = require("../di");
var ConfigValidator = /** @class */ (function () {
    function ConfigValidator(log, options, testFramework) {
        this.log = log;
        this.options = options;
        this.testFramework = testFramework;
        this.isValid = true;
    }
    ConfigValidator.prototype.validate = function () {
        this.validateTestFramework();
        this.validateThresholds();
        this.validateMutator();
        this.validateLogLevel('logLevel');
        this.validateLogLevel('fileLogLevel');
        this.validateTimeout();
        this.validatePort();
        this.validateIsNumber('maxConcurrentTestRunners', this.options.maxConcurrentTestRunners);
        this.validateIsStringArray('plugins', this.options.plugins);
        this.validateIsStringArray('reporters', this.options.reporters);
        this.validateIsStringArray('transpilers', this.options.transpilers);
        this.validateCoverageAnalysis();
        this.validateCoverageAnalysisWithRespectToTranspilers();
        this.crashIfNeeded();
    };
    ConfigValidator.prototype.validateTestFramework = function () {
        if (this.options.coverageAnalysis === 'perTest' && !this.testFramework) {
            this.invalidate('Configured coverage analysis "perTest" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to "all" or "off".');
        }
    };
    ConfigValidator.prototype.validateMutator = function () {
        var mutator = this.options.mutator;
        if (typeof mutator === 'object') {
            var mutatorDescriptor = mutator;
            this.validateIsString('mutator.name', mutatorDescriptor.name);
            this.validateIsStringArray('mutator.excludedMutations', mutatorDescriptor.excludedMutations);
        }
        else if (typeof mutator !== 'string') {
            this.invalidate("Value \"" + mutator + "\" is invalid for `mutator`. Expected either a string or an object");
        }
    };
    ConfigValidator.prototype.validateThresholds = function () {
        var thresholds = this.options.thresholds;
        this.validateThresholdsValueExists('high', thresholds.high);
        this.validateThresholdsValueExists('low', thresholds.low);
        this.validateThresholdValue('high', thresholds.high);
        this.validateThresholdValue('low', thresholds.low);
        this.validateThresholdValue('break', thresholds.break);
        if (thresholds.high < thresholds.low) {
            this.invalidate("`thresholds.high` is lower than `thresholds.low` (" + thresholds.high + " < " + thresholds.low + ")");
        }
    };
    ConfigValidator.prototype.validatePort = function () {
        if (this.options.port) {
            this.validateIsNumber('port', this.options.port);
            this.deprecate('port', objectUtils_1.normalizeWhiteSpaces("Test runners are expected to manage their own port selection.\n      I.e. please use karma.config.port, or leave it out entirely to let the test runner itself decide."));
        }
    };
    ConfigValidator.prototype.validateThresholdValue = function (name, value) {
        if (typeof value === 'number' && (value < 0 || value > 100)) {
            this.invalidate("Value \"" + value + "\" is invalid for `thresholds." + name + "`. Expected a number between 0 and 100");
        }
    };
    ConfigValidator.prototype.validateThresholdsValueExists = function (name, value) {
        if (typeof value !== 'number') {
            this.invalidate("Value \"" + value + "\" is invalid for `thresholds." + name + "`. Expected a number between 0 and 100");
        }
    };
    ConfigValidator.prototype.validateLogLevel = function (logProperty) {
        var logLevel = this.options[logProperty];
        var VALID_LOG_LEVEL_VALUES = [core_1.LogLevel.Fatal, core_1.LogLevel.Error, core_1.LogLevel.Warning, core_1.LogLevel.Information, core_1.LogLevel.Debug, core_1.LogLevel.Trace, core_1.LogLevel.Off];
        if (VALID_LOG_LEVEL_VALUES.indexOf(logLevel) < 0) {
            this.invalidate("Value \"" + logLevel + "\" is invalid for `logLevel`. Expected one of the following: " + this.joinQuotedList(VALID_LOG_LEVEL_VALUES));
        }
    };
    ConfigValidator.prototype.validateTimeout = function () {
        this.validateIsNumber('timeoutMS', this.options.timeoutMS);
        this.validateIsNumber('timeoutFactor', this.options.timeoutFactor);
    };
    ConfigValidator.prototype.validateCoverageAnalysis = function () {
        var VALID_COVERAGE_ANALYSIS_VALUES = ['perTest', 'all', 'off'];
        var coverageAnalysis = this.options.coverageAnalysis;
        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(coverageAnalysis) < 0) {
            this.invalidate("Value \"" + coverageAnalysis + "\" is invalid for `coverageAnalysis`. Expected one of the following: " + this.joinQuotedList(VALID_COVERAGE_ANALYSIS_VALUES));
        }
    };
    ConfigValidator.prototype.validateCoverageAnalysisWithRespectToTranspilers = function () {
        if (Array.isArray(this.options.transpilers) &&
            this.options.transpilers.length > 1 &&
            this.options.coverageAnalysis !== 'off') {
            this.invalidate("Value \"" + this.options.coverageAnalysis + "\" for `coverageAnalysis` is invalid with multiple transpilers (configured transpilers: " + this.options.transpilers.join(', ') + "). Please report this to the Stryker team if you whish this feature to be implemented");
        }
    };
    ConfigValidator.prototype.crashIfNeeded = function () {
        if (!this.isValid) {
            throw new util_1.StrykerError('Stryker could not recover from this configuration error, see fatal log message(s) above.');
        }
    };
    ConfigValidator.prototype.validateIsNumber = function (fieldName, value) {
        if (typeof value !== 'number' || isNaN(value)) {
            this.invalidate("Value \"" + value + "\" is invalid for `" + fieldName + "`. Expected a number");
        }
    };
    ConfigValidator.prototype.validateIsString = function (fieldName, value) {
        if (typeof value !== 'string') {
            this.invalidate("Value \"" + value + "\" is invalid for `" + fieldName + "`. Expected a string");
        }
    };
    ConfigValidator.prototype.validateIsStringArray = function (fieldName, value) {
        var _this = this;
        if (!Array.isArray(value)) {
            this.invalidate("Value \"" + value + "\" is invalid for `" + fieldName + "`. Expected an array");
        }
        else {
            value.forEach(function (v) {
                if (typeof v !== 'string') {
                    _this.invalidate("Value \"" + v + "\" is an invalid element of `" + fieldName + "`. Expected a string");
                }
            });
        }
    };
    ConfigValidator.prototype.invalidate = function (message) {
        this.log.fatal(message);
        this.isValid = false;
    };
    ConfigValidator.prototype.deprecate = function (deprecatedOption, message) {
        this.log.warn("Stryker option \"" + deprecatedOption + "\" is deprecated. " + message);
    };
    ConfigValidator.prototype.joinQuotedList = function (arr) {
        return arr.map(function (v) { return "\"" + v + "\""; }).join(', ');
    };
    ConfigValidator.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.testFramework);
    return ConfigValidator;
}());
exports.default = ConfigValidator;
//# sourceMappingURL=ConfigValidator.js.map